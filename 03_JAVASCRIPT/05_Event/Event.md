# 1. 이벤트 흐름
이벤트의 흐름이 생긴 배경
- 페이지의 어느 부분이 특정 이벤트를 소유해야 할까?
- 한 지점을 클릭하면 모든 레이어가 클릭되는 것과 같아졌다.
- 흐름을 따라 접근하는 방법으로 위의 문제를 해결했다.
- IE는 이벤트 버블링을 / 넷스케이프는 이벤트 캡처링을 지원했다.

## 1.1 이벤트 버블링
- 제일 깊은 곳에서 시작하여 올라가는 흐름이다.
- 물속에서 거품이 수면위로 올라오는 모습에서 모티브되어 버블링이라는 이름이 지어졌다.
- `document객체`를 만날 때까지 `DOM트리`를 거슬러 올라간다.
- 파폭, 크롬, 사파리는 `window객체`까지 올라간다.

## 1.2 이벤트 캡처링
- 최상위 노드에서 처음으로 이벤트가 발생한다.
- 이벤트가 의도한 요소에 도달하기 전에 잡아채려는 목적으로 디자인되었다.
- 파폭, 사파리, 크롬, 오페라, IE9 지원
- 오래된 브라우저에서는 이벤트 캡처링을 지원하지 않는다.
> 이벤트 버블링을 주로 사용하고, 이벤트 캡처링은 특별한 상황에서만 쓰길 권장.

## 1.3 DOM 이벤트 흐름
> 무슨말인지 잘 모르겠음.
1. 이벤트 캡처링 단계
2. 타깃 단계
3. 이벤트 버블링 단계

<hr>

# 2. 이벤트 핸들러
이벤트란?
- 사용자 또는 브라우저가 취하는 특정 동작이다.
- 특정 동작을 취하기 위해서는 이벤트 핸들러가 있어야한다.
- `click`, `load`...

이벤트 핸들러 (=이벤트 리스너)
- 이벤트에 응답하여 호출되는 함수
- 나영생각) 이벤트리스너는 직관적인 이름인듯!
- 이벤트 핸들러의 이름은 `on`으로 시작한다. 
- `onclick`, `onload`..

## 2.1 HTML 이벤트 핸들러
> 결론 : 단점이 많다.

- 핸들러 이름을 HTML속성에 사용하여 할당할 수 있다.
- 속성 값은 실행할 `자바스크립트 코드`여야 한다.
```html
<!-- 1. HTML에 이벤트 핸들러 할당방법 -->
<input type="button" value="Click Me" onclick="alert('Clicked')">
<!-- onclick 속성값에 자바스크립트 코드를 항당하여 정의된다. -->
<!-- HTML 엔티티를 피하기 위해서 속성값에는 작은따옴표를 썼다! -->

<!-- 2. 스크립트 연결하기 -->
<script type="text/javascript">
  function showMessage(){
    alert("Hello world!");
  }
</script>
<input type="button" value="Click Me" onclick="showMessage()">
```
- 이벤트 핸들러로 실행하는 코드는 전역 스코프에서 실행된다.

특징
- attribute 값을 감싸는 함수가 생성된다.
```html
<input type="button" value="Click Me" onclick="alert(event.type)">
<!-- evnet객체 -->

<input type="button" value="Click Me" onclick="alert(this.value)">
```
- 스코프 체인이 확장되는 방법.
  - `with`를 통해 이루어진다... (?)
  > 잘 모르겠다.

HTML에 이벤트 핸들러 할당방법의 단점
1. 타이밍 문제
  - 사용자가 이벤트 핸들러가 준비되기 전 조작할 가능성이 있다.
  - `try-catch`문을 이용해서 에러를 처리한다.
2. 스코프 체이닝 확장이 브라우저마다 다르다.
3. 이벤트 핸들러를 HTML에서 할당하면 HTML과 자바스크립트가 너무 단단히 묶인다.

<hr>

## 2.2 DOM 레벨0 이벤트 핸들러
이벤트 핸들러 프로퍼티에 함수를 할당하는 방법이다.
- 매우 단순하고, 모든 브라우저에서 지원하므로 최신 브라우저에서도 널리 쓰인다.
- 모든 요소에는 이벤트 핸들러 프로퍼티가 있다.
- 자바스크립트에서 이벤트 핸들러를 할당하려면 우선 객체에 대한 참조를 얻어야 한다.

```js
var btn = document.getElementById("myBtn");
btn.onclick = function(){
  alert("Clicked");
};
// 버튼에 대한 참조를 얻고, onclick 이벤트 핸들러를 할당했다.라고 한다.
```
- 이 코드가 버튼 마크업보다 뒤에 있다면 버튼을 클릭해도 아무 반응이 없는 시간에 존재할 수 있다.

- DOM 레벨 0 방법으로 이벤트 핸들러를 할당하면 이벤트 핸들러는 해당 요소의 메서드로 간주
  - 이 이벤트 핸들러는 요소의 스코프에서 실행되며 `this는 요소 자체`이다.
```js
var btn = document.getElementById("myBtn");
btn.onclick = function(){
  alert(this.id); //"myBtn"
};
```

이벤트 핸들러 제거 방법
- 이벤트 핸들러 프로퍼티를 null로 설정한다.
```js
btn.onclick = null; //이벤트 핸들러 제거
```

## 2.3 DOM 레벨2 이벤트 핸들러
## 2.4 인터넷 익스플로러 이벤트 핸들러
## 2.5 크로스 브라우저 이벤트 핸들러

<hr>

# 3. event 객체
## 3.1 DOM event 객체
## 3.2 인터넷 익스플로러의 event 객체
## 3.3 크로스 브라우저 이벤트 객체

<hr>

# 4. 이벤트 타입
## 4.1 UI 이벤트
## 4.2 Focus 이벤트
## 4.3 마우스 이벤트와 휠 이벤트
## 4.4 키보드와 텍스트 이벤트
## 4.5 조합 이벤트
## 4.6 matation 이벤트
## 4.7 HTML5 이벤트
## 4.8 장치 이벤트
## 4.9 터치와 제스처 이벤트

<hr>

# 5. 메모리와 성능
## 5.1 이벤트 위임
## 5.2 이벤트 핸들러 제거

<hr>

# 6. 이벤트 시뮬레이션
## 6.1 DOM 이벤트 시뮬레이션
## 6.2 인터넷 익스플로러의 이벤트 시뮬레이션