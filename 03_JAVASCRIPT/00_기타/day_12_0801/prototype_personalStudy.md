> 마구잡이 정리 중임을 알립니다..
> 내 머리 속도 마구잡이..

출처 : 
- [자바스크립트 생성자](http://webclub.tistory.com/239)
- [Function 생성자 및 인스턴스](http://webclub.tistory.com/380)
- [자바스크립트 상속-과정이 자세함](http://jusungpark.tistory.com/38)
<hr>

<img src="/day_13_0802/Prototype_chain.jpg">

<hr>

- 객체는 이름, 값 쌍의 그룹이며 각 값은 데이터나 함수가 될 수 있다.
- 객체는 특정 참조 타입의 '인스턴스'이다.
- 모든 객체는 참조타입이다.
  - 네이티브 타입
  - 개발자가 정의한 타입
- 데이터를 의미하는 프로퍼티
- 동작을 나타내는 메서드
  - 메서드는 객체에 제한되어 있는 함수를 의미한다. 즉 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 칭한다.


## Prototype을 이해해보자..
- 자바스크립트 파싱 단계가 끝나고 나서 생성자를 이용해 객체가 정의되면 단순히 객체만 생성되는 것이 아니라 그 객체와 관련된 상속 관계도 결정된다. 따라서 상속을 이해하려면 함수와 객체의 생성 절차를 살펴보는것이 도움이 된다. 출처: http://jusungpark.tistory.com/38 [정리정리정리]
```
var person = new Object();
```
= person이라는 이름으로 Object(객체)의 인스턴스를 만듦.
- 인스턴스란? : 객체를 생성하기 위해 만들어진 또 다른 객체 [출처](https://goo.gl/tKYhPV)
  - 객체와 유사하다.
  - 다만, 의미상으로 "객체"는 좀더 일반적인 의미인 반면에 "인스턴스"라고 표현하면 **"현재 생성된 바로 그 객체"**라는 인스턴트(instant)한 뉘앙스로 <u>좀 더 짙게 표현</u>할 수 있습니다. [출처](http://webclub.tistory.com/380)
  - 인스턴스를 생성하는데 사용하는 함수를 특별히 **생성자(constructor)**라고 하는데 Object가 Object 인스턴스를 생성하는 생성자라면 Function은 함수 인스턴스를 생성하는 생성자라고 할 수 있습니다.
  - 함수를 정의한다는 것"과 "함수 인스턴스를 생성한다는 것"의 **표현은 다르지만 의미상으로는 거의 동일**하다고 할 수 있습니다.

2. 의문1) 왜 Object() 생성자 **함수**라고 사용할까.
- Prptotype을 배우면서 Function 생성자와 Object생성자가 있다는 것을 알게되었는데, 앞부분에서 배울 때 함수는 참조타입의 **객체**라고 알고 있었음. ('기본자료형(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.')
  1. 그럼 결국 객체가 함수보다 좀더 상위 개념이 아닐까 생각함.
  2. 그런데 Object()를 생성자 <u>함수</u>라고 했음.. Funtion은 **생성자** 라고만 하면서 Object는 Object 생성자 **함수**라고 함..
    - (출처:생코) 일반적인 객체지향 언어에서 생성자는 클래스의 소속이다. 하지만 자바스크립트에서 **<u>객체</u>를 만드는 주체는 <u>함수</u>**다. 함수에 new를 붙이는 것을 통해서 객체를 만들 수 있다는 점은 자바스크립트에서 함수의 위상을 암시하는 단서이면서 또 자바스크립트가 추구하는 자유로움을 보여주는 사례라고 할 수 있다. 
    - 결국 **Function은 객체이면서 동시에 함수**이며, Object() 생성자도 객체이지만, **Function 인스턴스**인 것.
  3. **Object 생성자 <u>함수</u>**를 이용해서 Object 인스턴스를 만든다는 것을 Object를 새롭게 정의한다는 말과 동일하게 생각하면 될듯. (좀더 자세한 프로세스는 아래 그림)

  - 흠.. Function 프로토타입에서 에서 __proto__를 보면 Object가 나오는데. 그말은 Function의 부모는 Object라는 말 아닌가..?
    - 그럼 앞에서 얘기한 Object 생성자는 Function의 인스턴스라는 말이랑 비교하면.. 말이 안되는 상황인데?

  - 해결.. 최상위 개념인 Object와 Object()생성자(함수)를 햇갈렸다. (Object)
    - Function 프로토타입에서 __proto__를 보면 Object가 나오는 것은 상속관계에서 최상위 부모가 Object라서 나오는 것이다. (Object생성자 함수를 통해서 나온 Object인스턴스와는 다른 개념..)
    - Object 생성자 **함수**라는 것은.. 생성자함수가 상위개념인 Object에서 인스턴싱이 되면서, 생성자 함수의 멤버가 추가되는데, Object() 생성자 함수 즉 객체 리터럴로 선언될 때 같은 방식으로 진행되기 때문에 **생성자 함수**라는 말이 붙은것이다.
    
2. 메서드와 함수의 차이

- 메소드(method)
  - 메소드는 객체가 가지고 있는 동작이다. 이 동작이란 의미에서 함수와 메소드를 구분하지 못하는 분들도 많다. 기본적으로 함수와 메소드가 서로 일련의 동작을 실행한다는 점에서 동일하기 때문이다. 하지만 **메소드와 함수는 엄연하게 서로 다른 녀석이다.** 메소드와 함수의 차이가 무엇인지 궁금한 분을 위해 잠깐 그 차이를 설명하고 넘어가겠다
  - 메소드는 위에서 설명하였듯이 **객체가 가지고 있는 동작**이다. 메소드를 수행하기 위해서는 **객체를 통해서 해당 메소드를 수행하여야 한다.** 즉 **그 동작을 수행하는 주체는 객체**이며 그 동작을 수행하기 위해서는 객체에게 그 동작을 수행하라고 **지시**해야 한다. **함수는 그 동작을 수행하기 위해 객체에게 어떤을 동작을 수행하라고 명령하지 않아도 된다.** 그이유는 **함수자체가 그 동작을 정의한 함수객체**이기 때문에 **자기 자신을 수행**하는 것이다. 함수객체라는 것에 대해서는 이후에 자세히 설명하도록 하겠다. 어찌 되었건 메소드는 객체를 움직이는 동작이며 그 동작을 수행하기 위해서 객체의 정보를 담고있는 프로퍼티를 사용할수 있다.

3. 의문2) 그럼 함수를 생성할때, 개념적으로는 Function 생성자 함수를 사용해서 선언하는데, 왜 Function이라고 안쓰고 function이라고 쓸까.
```
var square = new Function('number', 'return number * number');
console.log(square(10)); // 100
```
  - (함수 파트에서 배웠음) Function으로 생성하는 어려운 방법(Function 생성자함수)을 단순화 시키기 위해 function을 쓰는 것이다. (함수 선언식, 함수 표현식)
    - 앞의 함수를 생성할 때 Function 을 이용하는 코드와 function 을 이용하는 코드를 보면 알겠지만 Function을 사용하기는 어렵습니다.
    - 함수 본문이 길어진다면 마지막 인자에 문자열로 본문을 작성하는 것을 결코 쉽지 않은 일입니다.
    - 따라서 함수를 정의할 때는 Fucntion 보다는 function을 주로 이용합니다.



### 생성자함수에서 Object인스턴스 생성 과정
<img src="http://cfile27.uf.tistory.com/image/27025645586E4A400CEAEA">

- 인스턴스를 생성할 때 자바스크립트는 인스턴스 내부에 그 생성자의 프로토타입 객체를 참조하기 위해 __proto__라는 이름의 속성을 추가해 **인스턴스가 프로토타입 객체의 멤버를 상속하는 메커니즘을 구현하는 근거로 삼는다**고 했다.
- new 키워드로 생성자를 이용해 인스턴스를 생성할때 __proto__ 가 만들어지는데 이때 prototype이 가리키고 있는 객체를 이용해서 만들어진다.

<img src="http://cfile4.uf.tistory.com/image/22376042586E4DC50CB654">

- 프로토타입 멤버는 해당 생성자로 생성된 모든 인스턴스가 공유할 수 있다고 했다. 이것이 가능한 이유는 모든 인스턴스가 __proto__속성을 이용해 자신의 프로토타입 객체에 접근해서 멤버를 검색할 수 있기 때문이다.
- 모든 인스턴스는 해당 생성자의 프로토타입 멤버를 상속한다.


#### 배운거 이해하기.
### 프로토타입에 직접적으로 할당한 후 객체를 복사하는 코드 / 프로토타입에 매개변수가 들어가게끔만 틀을 만들고, 객체 인스턴스를 생성할 때마다 변수를 다르게 할당 할 수 있는 코드(붕어빵 틀 예제)

1. 프로토타입에 직접적으로 할당 후 객체 인스턴스를 생성
```
function Person() {
} // Person 타입을 정의하는데, 타입안에는 프로퍼티와 메서드가 없다. (이때 Person은 함수명이기도 하면서 할당된 변수명이다.)

Person.prototype.name = "nayoung"
Person.prototype.age = "27"
Person.prototype.job = "front-end Developer"
Person.prototype.sayJob = function() {
  alert(this.job);
}
// Person의 prototype에 직접적으로 할당하였다. 
 
var person1 = new Person(); //Person 인스턴스를 생성하여 person1에 저장함. 
                            //Person 생성자 함수가 person1이라는 객체 인스턴스를 생성했다.
                            // 생성하는 방법은 1. 자바스크립트가 new Person()을 만나는 순간 Object 인스턴싱이 진행되어 빈 객체가 생성(왜? Person은 생성자 함수이고, new를 사용하면서 객체 인스턴스를 만든다고 지시하기 때문에) 2. 생성자 함수 Person의 프로퍼티들(멤버)들이 추가 3. Person 인스턴스 탄생
person1.sayJob(); // Person()의 프로퍼티들이 상속되었기 때문에 person1에서 sayJob()메서드를 생성할 수 있는 것이다.

var person2 = new Person();
person2.sayJob(); // 또 다른 변수에 할당 가능하다.
```
- 아, 함수를 **참조**하기 때문에 기본형데이터타입을 할당하는 것보다 메모리에 무리가 가지 않겠다.
- 즉, 새롭게 선언한 객체 인스턴스의 순서에서 2번부분에서는 추가라기보다는 참조의 개념인듯. > function의 값을 수정하면 다 수정됨. 

2. 프로토타입에 매개변수가 들어가게끔만 틀을 만들고, 객체 인스턴스를 생성할 때마다 변수를 다르게 할당 할 수 있는 코드(붕어빵 틀 예제)

```
var Person = function (name, age, job){ //함수표현식으로 변수명 Peson에 함수를 할당하였다. Person생성자함수로 객체 인스턴스를 생산 후 매개벼수를 받기 위해서 인자를 셋팅하였다. 생성자 함수는this를 반환하는데, 이는 일반함수와 차이점이다.
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayJob = function{
    return this.job
  };
};

var person1 = new Person('nayoung','27','front-end developer');
```
- 이는 같은 인자에 한 객체당 다양한 값을 할당 할때 사용..(?)
- this가 생성자 호출패턴으로 바인딩 되는 개념이다. [this_생성자호출패턴](http://poiemaweb.com/js-this#1-메소드-호출-패턴method-invocation-pattern) 
> 각 변수마다 메모리가 어떻게 할당이 되는지 궁금하다.....

<hr>

- 생성자를 호출해서 인스턴스를 생성할 때마다 해당 인스턴스 내부에는 생성자의 프로토타입을 가리키는 포인터가 생성된다. (즉, 인스턴스의 부모를 가리키는 포인터가 생성)
  - 이를 [[Prototype]]이라고 불림
  - 생성자 자체와 연결되지 않는다.
- 생성자(constructor)는 prototype에만 존재한다.
- 객체에서 프로퍼티를 읽으려 할 때마다 해당 프로퍼티 이름으로 찾으려고 검색합니다. 검색은 객체 인스턴스 자체에서 시작합니다. 인스턴스에서 프로퍼티 이름을 찾으면 그 값을 반환합니다. 프로퍼티를 찾지 못하면 **포인터(__proto__)를 프로토타입으로 올려서 검색을 계속**합니다. 프로퍼티를 프로토타입에서 찾으면 그 값을 반환합니다.(p.230) >> **프로토타입 체인**
- 일단 객체 인스턴스에 프로퍼티를 추가하면 해당 프로퍼티는 프로토타입에 존재하는 같은 이름의 프로퍼티를 '가립니다.' = 인스턴스에 프로퍼티가 있으면 프로토타입에 존재하는 같은 이름의 프로퍼티에 대한 접근은 차단된다.
- 만약 다시 접근하고 싶을 경우, 추가한 프로퍼티를 **삭제**하면된다.
  ```delete person1.name;```

- Person.prototype.isPrototypeOf(person1)은 person1에 프로토타입 연결이 존재하는지(__proto__) 확인하는 것이다. 
- ES5에 [[Prototype]]의 값을 반환하는 Object.getPrototypeOf()라는 메서드가 추가되었음.
  ```Object.getPrototypeOf(person1).name == "nayoung```

#### hasOwnProperty()
- 프로퍼티가 인스턴스에 존재하는지 / 프로토타입에 존재하는지 확인.
- Object로부터 상속받은 메서드다!!
- true / false로 확인한다.
- person1.hasOwnProperty("name")

#### 프로토타입의 동적 성질
- ```__proto__```는 (포인터)는 생성자가 호출될 때 할당됨. 프로토타입을 다른 객체로 바꾸면 생성자와 원래 프로토타입 사이의 연결이 끊어짐. 다시한번 강조! 인스턴스는 프로토타입을 가리키는 포인터를 가질 뿐 생성자와 연결된 것이 아니다.
- 프로토타입 객체를 새로 바꿀 경우 생성자는 새로운 프로토타입을 참조하지만(기존의 같은 주소상에서 변한거기 때문에), 프토토타입을 가리키고 있었던 객체는 여전히 빈 객체를 가리키고 있는 것이다.

<img src= "/asset/New_Prototype.jpeg">

- 모든 객체는 ```__proto__```가 존재함. prototype은 함수에 존재함.

### 표준 built in 객체
- Object / Function / Boolean / Number / Math / Date / String / RegExp / Array / Error / Symbol
- 우리가 공장이라고 말했던 것들을 표준 built-in-Object라고 한다.
<img src ="http://poiemaweb.com/img/object.png">


> Codecademy의 javascript 트랙 중 섹션 6에서 섹션 8까지 공부한다.(Data Structures ~ Object2)
> 콘솔창에 찍으면서 하는 건 지금은 좀 적당히 하자.. 상당히 헷갈림 ㅜ