Form 예제 - 할일 관리 웹 서비스
===

이 프로젝트는 간단한 할일 관리 웹 서비스를 구현한 것입니다. 할 일 목록 페이지, 할 일 편집 페이지로 구성되어 있습니다. 데이터는 Node.js 서버의 메모리에 저장되므로, 코드를 편집하거나 접속자가 없어서 서버가 재시작되면 변경된 데이터가 사라집니다.

먼저 상단의 `Show [Live]` 버튼을 눌러 서비스를 사용해보고, 그 다음 `server.js`의 각 라우트 핸들러가 어떤 일을 하고 있는지 살펴보세요.

## UUID (Universally unique identifier)

인터넷 상의 수많은 자료를 구분하기 위해 각 자료에 식별자(identifier)를 부여하는 일은 아주 중요합니다. 식별자를 부여하는 가장 쉬운 방법은 자료가 생성된 순서대로 번호를 붙이는 것입니다. 실제로 많은 데이터베이스에서 이런 방법을 사용하고 있습니다. 하지만 환경에 따라 자료가 생성되는 순서를 알 수 없는 경우도 있습니다.

UUID는 식별자로 사용하기 위해 고안된 수 형식이며, 아래와 같은 형식으로 표현됩니다.

`424e19f5-f330-4be1-889f-4a9f7da75b69`

UUID는 표현할 수 있는 경우의 수가 무지무지무지무지 많습니다. (128bit = 2의 128제곱) UUID 난수를 생성하는 표준적인 방법(UUID version 4)을 사용하면, 언제 어디서 UUID를 생성해도 정확히 같은 UUID가 생성될 수 있는 확률이 매우매우매우매우 작기 때문에 안심하고 식별자로 사용할 수 있습니다.

이 프로젝트에서는 UUID를 생성하기 위해 `uuid` npm 패키지를 사용했습니다.

## POST method

각각의 HTTP 메소드들이 갖고 있는 의미와 다르게, 이 프로젝트에서는 자료의 수정이나 삭제를 할 때에도 POST 메소드를 사용하고 있습니다. HTML form은 기본적으로 GET과 POST 밖에 지원하지 않으므로, 순수 HTML만을 사용해서 웹 서비스를 구현한다면 이러한 방식으로 구현해야 합니다. Ajax를 사용한다면 PUT이나 DELETE 등의 메소드를 사용할 수 있어서, HTTP 메소드의 의미에 맞게 구현을 할 수 있을 것입니다.

## Redirect after submission

순수한 HTML form을 이용해 POST 메소드로 자료를 전송한 후에는 꼭 리디렉션을 통해 응답해야 합니다. 특히 302 상태 코드를 사용해 응답해야 합니다.

POST 메소드 요청에 일반적인 응답(2xx)을 하게 되면, 해당 페이지를 새로고침을 했을 때 이전에 보냈던 요청을 그대로 다시 보내게 되기 때문에, 자료가 이중으로 전송되게 됩니다. `server.js`에서 주석을 해제해서 테스트해볼 수 있습니다. 단, 이는 순수 HTML form을 사용했을 때만 해당되며, Ajax를 통해 자료를 전송하는 방식이라면 2xx 상태코드의 일반적인 응답을 해도 괜찮습니다. (사용자가 Ajax를 새로고침할 수 있는 방법은 없기 때문입니다.)

301 상태코드(Moved Permanently)를 사용하면 안되는 이유는 브라우저 캐시 때문입니다. 브라우저가 한 번 301 응답을 받게 되면, 그 결과를 저장해두었다가 사용자가 같은 요청을 보내려고 할 때 서버에 요청을 보내지 않고 미리 저장해둔 응답을 대신 보여줍니다. 만약 사용자의 폼 전송에 대해 한 번 301 상태코드로 응답하게 되면, 사용자가 나중에 같은 내용으로 폼을 전송하려고 했을 때 제대로 전송되지 않을 것입니다.

## Form validation

사용자가 입력하는 자료는 개발자가 기대하는 형식과는 영 딴판일 수 있습니다. 필요한 필드가 없을 수도 있고, 자료의 형식을 서버가 이해할 수 없는 경우도 있습니다. 이런 자료를 데이터베이스에 그냥 집어넣게 되면 데이터베이스가 뒤죽박죽이 되고 말 것입니다. 그래서, 사용자에게 입력받은 자료는 처리를 하기 전에 항상 올바른 형태인지 검증해야 합니다. 이런 검증 과정을 form validation이라고 합니다.

form validation을 구현하는 전형적인 방법은 다음과 같습니다.

1. 사용자가 폼을 작성합니다.
1. 사용자가 폼을 서버에 전송합니다.
1. 서버는 기대한대로 데이터가 들어왔는지 검사합니다.
1. 서버는 데이터가 기대한 대로 잘 들어왔으면 다음 단계를 진행하고, 데이터에 문제가 있다면 어떤 문제가 있는지를 사용자에게 알려줍니다. (이 프로젝트에서는 데이터에 문제가 있으면 단순하게 400 Bad Request 응답을 하고 있지만 사용자 경험을 위해서는 이렇게 하면 안되겠죠?)

서버 측에서 하는 form validation은 꼭 필요하지만, 사용자가 자료를 서버에 전송해야만 데이터에 어떤 문제가 있는지를 알 수 있다는 단점이 있습니다. 사용자 입장에서는 실컷 폼을 다 작성해서 전송했더니 폼에 에러가 있다고 하며 중간 단계부터 다시 시작해야 하니 짜증이 날 것입니다. 아마 여러분도 비슷한 경험이 있을 것입니다.

서버 측 validation을 잘 구현해서 사용자가 덜 불편하게끔 만드는 방법도 있지만 **폼을 서버에 전송해야** 피드백을 받을 수 있다는 점은 변하지 않습니다. 더 나은 사용자 경험을 위해 클라이언트 측 validation을 하는 것을 고려해볼 수 있습니다.

클라이언트 측 validation은 사용자가 폼을 작성하는 도중에 피드백을 받을 수 있다는 점에서 서버 측 validation보다 훨씬 나은 사용자 경험을 제공할 수 있습니다. 대신 서버 측 코드에서 하는 데이터 검사 로직을 클라이언트 측 코드에도 중복 구현해야 한다는 어려운 점이 있습니다. 다행히 HTML5에 추가된 form validation 기능을 이용하면 간단한 validation은 자바스크립트 코드를 하나도 짜지 않고도 구현할 수 있습니다. HTML5 form validation을 시험해 보려면, `index.ejs` 파일의 title 필드에 `required` 속성을 추가해보세요.

HTML5 form validation은 사용하기 간편하고, 브라우저에 내장되어 있다는 점에서 (특히 모바일에서) 일관성있는 사용자 경험을 제공할 수 있다는 장점이 있습니다. 하지만 HTML5를 지원하지 않는 구형 브라우저에서는 사용할 수 없고, 또 복잡한 형태의 validation은 지원하지 않는다는 단점이 있습니다. (여러 필드의 자료를 합쳐서 validation을 한다거나, validation을 하기 위해 서버에 요청을 해야 하는 등)

**주의!** 클라이언트 측 validation을 하더라도 서버 측에서는 반드시 validation을 따로 해주어야 합니다. 사용자가 언제나 우리가 제공하는 클라이언트를 사용한다는 보장은 없기 때문입니다. (예를 들면 악의적인 해커가 Postman 등을 이용해 이상한 요청을 보낼 수도 있겠죠?)